---
title: "securing snake"
date: "2024-11-19"
readingTimeMin: 5
meta:
  "og:title": "securing snake"
  "og:description": "how i secured a snake leaderboard (and made it fun for devs)"
  "twitter:card": "summary"
  "twitter:title": "securing snake"
  "twitter:description": "how i secured a snake leaderboard (and made it fun for devs)"
  "twitter:image": "https://basecase.vc/securing-snake/og.jpg"
---

over the weekend, i added a live leaderboard for the snake game on my website. it was a super fun
feature, but like many of my projects, i shipped it with some apparent security issues. this is a
quick write up on how i went from "anyone can hack this" to a reasonably secure implementation,
along with some code and lessons learned.

## the naive implementation: client-side score submission

initially, the snake game and leaderboard updates ran entirely client-side. the snake component
would send your score to supabase directly, and since i didn't want users to have to authenticate to
play the game or appear on the leaderboard, the rls (row level security) policies were set up to
allow anyone to read, insert, and update from the leaderboard table. this seemed fine at first, but
i quickly realized that anyone could inspect the network requests and submit scores via curl, like
this:

```bash
# send a request to supabase

curl 'https://supabase.co/rest/v1/leaderboard?on_conflict=username' \
 -H 'apikey: <supabase-key>' \
 -H 'authorization: Bearer <supabase-key>' \
 --data-raw '{"username":"pk_iv","score":999999,"submitted_at":"2024-11-17T17:45:22.381Z"}'
```

within minutes, i had leaderboard entries with impossibly high scores showing up. shout out to pk_iv
for being the first.

## moving to rpc functions (and why that wasn't enough)

for my first attempt to secure the leaderboard, i thought i would use a supabase rpc (remote
procedure call) function instead of allowing direct inserts to the database. the rpc function added
a layer of abstraction and some basic validation, but still ran on the client, so anyone could see
the rpc call and submit scores using another simple curl command:

```bash
# send a request to the rpc function
curl 'https://supabase.co/rest/v1/rpc/submit_score' \
 -H 'apikey: <supabase-key>' \
 --data-raw '{"username":"hacker","score":999999}'
```

still a piece of cake. i had more work to do.

## adding server-side validation

i realized that i'd need a more robust solution to at least make hackers break a sweat, so i moved
the score submission logic to the server. the server would validate the score by checking the
timestamp: you could only submit a score where the time-to-score ratio made sense (e.g. 1 point per
second). this was a step in the right direction, making it at least more than a simple curl command
to game the system. but again, those curious or determined enough found a workaround by calculating
a different start time:

```bash
# send a request to the backend with a manipulated game start time

curl 'https://www.basecase.sh/api/submit-score' \
  -H 'accept: */*' \
  -H 'content-type: application/json' \
  -H 'origin: https://www.basecase.sh' \
  -H 'referer: https://www.basecase.sh/' \
  --data-raw '{"username":"ejcx","score":1337,"gameStartTime":1721889984973}'
```

this was a pretty reasonable fix, but it was still too easy to hack.

## introducing jwt tokens

alas, it was time to get serious. enter jwts: jwts (json web tokens) are a secure way to transmit
information between parties as a json object. they're signed using a secret key that only the server
knows, making them tamper-proof. when you sign data into a jwt, that data becomes immutable. any
attempt to modify the token's contents invalidates the signature, so the server will reject it. this
was perfect for my use case: i could essentially "lock" the start time into a token that players
couldn't manipulate.

here's how i implemented it:

1. when a game starts, the client requests a token from the server. the server creates a jwt
   containing the exact start timestamp and signs it with a secret key.
2. this token is tied to the start time of the game. the timestamp is encrypted inside the token's
   payload and can't be changed without breaking the signature.
3. when the game ends, the token is submitted along with the score. the server verifies the token's
   signature and extracts the original start time.

this means that hackers can't easily fake timestamps because the token's start time is baked into
its payload and cryptographically signed. even if someone is able to fetch a token, they still have
to wait in real-time to submit a high score, since the start time can't be manipulated. and yet
again, that window of opportunity was all it took:

```bash
# fetch a game token
TOKEN=$(curl www.basecase.sh/api/start-game -XPOST | jq -r .token)

# wait 5 seconds, then submit a score
curl -d "{\"gameToken\":\"$TOKEN\", \"username\":\"hacker\", \"score\":5}" www.basecase.sh/api/submit-score
```

i also added a 10-minute expiration to the tokens to prevent players from starting a game and
waiting too long to submit an artificially high score. this added a lot more friction for hackers,
but i still wasn't done.

## detecting unrealistic scores

finally, i added a manual check for suspiciously high scores. if someone submits a score over 300,
the server rejects it with a message that pokes a little fun:

```javascript
// check for suspiciously high scores
if (score > 300) {
  return NextResponse.json({
    success: false,
    message: "impressive work! send a screenshot of your score to @alanaagoyal",
  });
}
```

lessons learned this journey taught me a lot about securing small projects:

1. client-side code is never secure. anything on the client can and will be inspected, so always
   validate on the server.
2. layered defenses work best. combining techniques (e.g., backend validation, tokens, and manual
   checks) makes it much harder to hack a system.
3. embrace the playful side. adding a fun response to suspicious scores made the game feel less
   rigid and more personal.

if you're a dev working on your own projects, i hope this breakdown helps you think about security
in a practical way. and if you happen to submit a 300+ score, donâ€™t forget to send me a screenshot
:)
