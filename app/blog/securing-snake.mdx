---
title: "securing snake"
date: "2024-11-19"
readingTimeMin: 5
meta:
  "og:title": "securing snake"
  "og:description": "how i secured a snake leaderboard (and made it fun for devs)"
  "twitter:card": "summary"
  "twitter:title": "securing snake"
  "twitter:description": "how i secured a snake leaderboard (and made it fun for devs)"
  "twitter:image": "https://basecase.vc/securing-snake/og.jpg"
---

over the weekend, i launched a live leaderboard for the snake game on my website. it was a fun
feature, but i shipped it with some obvious security issues. this is a quick write up on how i went
from "anyone can hack this" to "reasonably secure" in 24 hours.

## the naive implementation

initially, all of the snake game and leaderboard code ran client-side. the snake component contained
the logic for the game, scoring, and submission to supabase. since i didn't want users to have to
authenticate to play the game, i set up the rls (row level security) policies to allow anyone to
read, insert, and update the leaderboard table. this seemed fine at first, but i quickly realized
that anyone could inspect the network requests and submit scores via curl:

```bash
# send a request to supabase

curl 'https://supabase.co/rest/v1/leaderboard?on_conflict=username' \
 -H 'apikey: <supabase-key>' \
 -H 'authorization: Bearer <supabase-key>' \
 --data-raw '{"username":"hacker","score":999999,"submitted_at":"2024-11-17T17:45:22.381Z"}'
```

i tweeted about the launch early on sunday morning. within minutes, i had leaderboard entries with
impossibly high scores showing up. shout out to @pk_iv for being the first.

## the first attempt: rpc functions

at this point, it was around 10a, and my tweet was starting to gain traction. i wanted to put out a
quick fix, but didn't want to ship anything too crazy while the traffic was spiking. my first
thought was to use a supabase rpc (remote procedure call) function instead of allowing direct
inserts to the database. the rpc function added a layer of abstraction and some basic validation,
but still ran on the client. once again, anyone could see the rpc call and submit scores using
another simple curl command:

```bash
# send a request to the rpc function

curl 'https://supabase.co/rest/v1/rpc/submit_score' \
 -H 'apikey: <supabase-key>' \
 --data-raw '{"username":"hacker","score":999999}'
```

still too easy. i had more work to do.

## adding server-side validation

by the time noon rolled around, i knew i'd need a more robust solution. begrudgingly, i moved the
score submission logic to the server. this way, the server would validate the score by checing
whether a score was possible given the time it took to submit the score. this was a step in the
right direction, making it at least more than a simple curl command to game the system. surely i
should have known that this was not the end of the story. it was only a matter of time before
someone submitted a new high score by manipulating the game start time:

```bash
# send a request to the backend with a manipulated game start time

curl 'https://www.basecase.sh/api/submit-score' \
  -H 'accept: */*' \
  -H 'content-type: application/json' \
  -H 'origin: https://www.basecase.sh' \
  -H 'referer: https://www.basecase.sh/' \
  --data-raw '{"username":"hacker","score":1337,"gameStartTime":1721889984973}'
```

shout out to @ejcx for being the first to break the new system.

## introducing jwt tokens

alas, it was time to get serious. it was almost dinner time and i was determined to ship a more
secure solution before going to bed. enter jwts: a jwt (json web token) can be used to securely
transmit information between parties as a json object. jwts are signed using a secret key that only
the server knows, making them tamper-proof. once a jwt is signed, the data becomes immutable. any
attempt to modify the token's contents invalidates the signature and it will be rejected by the
server. this was perfect for my use case: i could essentially encode the start time into a token
that would be impossible to manipulate.

here's how it works:

1. when a game starts, the client requests a token from the server. the server creates a jwt
   containing the exact start timestamp and signs it with a secret key.
2. this token is tied to the start time of the game. the timestamp is encrypted inside the token's
   payload and can't be changed without breaking the signature.
3. when the game ends, the token is submitted along with the score. the server verifies the token's
   signature and extracts the original start time.

if users are clever enough to fetch the token, they won't be able to manipulate the start time, but
they can just wait in real-time to submit a higher score (or write a script to do so):

```bash
# fetch a game token

TOKEN=$(curl www.basecase.sh/api/start-game -XPOST | jq -r .token)

# wait 5 seconds, then submit a score
curl -d "{\"gameToken\":\"$TOKEN\", \"username\":\"hacker\", \"score\":$SCORE+5}" www.basecase.sh/api/submit-score
```

i added a 10-minute expiration to the tokens to prevent players using this technique to submit too
high of a score. exhasted from a day of fending off hackers, i was ready to call it a night. at
least i knew anyone trying to game the system would need to put in real effort.

## detecting unrealistic scores

i woke up the next morning to find a new leaderboard entry with a score of 500 (shout out to @mish).
at this point, i was more impressed than anything, so i came up with one final plan. in the
server-side submission logic, i added a check to determine if the score is suspiciously high. if so,
i reject it with a message that pokes a little fun:

```javascript
// check for suspiciously high scores

if (score > 300) {
  return NextResponse.json({
    success: false,
    message: "impressive work! send a screenshot of your score to @alanaagoyal",
  });
}
```

if someone is smart enough to hack the system, i want to hear from them.

## lessons learned

i learned a few things from this experience:

1. client-side code is never secure. anything on the client can and will be inspected, so always
   validate on the server.
2. layered defenses work best. combining techniques (e.g. backend validation, tokens, and manual
   checks) makes it much harder to hack a system.
3. there's always more you can do. the pursuit of securing a system is never done.

there are clearly additional measures i could take to further secure the system. i could implement
rate limiting to prevent brute force attempts, add captcha verification to ensure players are human,
or use browser fingerprinting to detect suspicious patterns. i could also store gameplay telemetry
(like keystrokes and timing) to analyze for bot-like behavior. for a simple snake game, these would
be overkill, but they're good examples of how security can be continuously improved in layers.

## final thoughts

i often get asked why i spend so much time writing code as a venture capitalist. the answer is
simple: it helps me build empathy for the founders and builders i get to work with. in my case, the
stakes were low. when founders face similar security challenges in their startups, they're dealing
with real users, real data, and real business impact. experiencing these challenges firsthand, even
at a small scale, makes me a more empathetic investor and partner.

it's also fun to meet the folks who are curious and creative enough to hack my projects. if you're
the type of person who enjoys reverse engineering systems, finding clever workarounds, or just
pushing the boundaries of what's possible, i'd love to chat. i'm constantly looking to meet super
talented, curious people who can think outside the box. feel free to reach out to me on
[twitter](https://twitter.com/alanaagoyal) or [email](mailto:alana@basecase.vc).
