---
title: 'how i secured a snake leaderboard (and made it fun for devs)'
date: '2024-01-17'
meta:
  'og:title': 'how i secured a snake leaderboard (and made it fun for devs)'
  'og:description': 'a journey from insecure to secure, with some fun dev easter eggs along the way'
  'twitter:card': 'summary'
  'twitter:title': 'how i secured a snake leaderboard (and made it fun for devs)'
  'twitter:description': 'a journey from insecure to secure, with some fun dev easter eggs along the way'
readingTimeMin: 5
---
over the weekend, i added a live leaderboard for the snake game on my website. it was a fun project, but like most quick builds, it had some serious security issues. here's the journey of how i went from "anyone can hack this" to a reasonably secure implementation, along with some code and lessons learned.

## the naive implementation: client-side score submission

initially, the snake game and leaderboard updates ran entirely client-side. the snake component would send your score to supabase directly, and since i didn't want users to have to authenticate to play the game or appear on the leaderboard, the rls (row level security) policies were set up to allow anyone to read, insert, and update from the leaderboard table. this seemed fine at first, but i quickly realized that anyone could inspect the network requests and submit scores via curl, like this:

```bash
curl 'https://supabase.co/rest/v1/leaderboard?on_conflict=username' \
 -H 'apikey: <supabase-key>' \
 -H 'authorization: Bearer <supabase-key>' \
 --data-raw '{"username":"pk_iv","score":999999,"submitted_at":"2024-11-17T17:45:22.381Z"}'
```

within minutes, i had "players" with impossibly high scores showing up. shout out to pk_iv for being the first.

## moving to rpc functions (and why that wasn't enough)

in my first attempt to secure the leaderboard, i switched to using a supabase rpc (remote procedure call) function instead of allowing direct inserts to the database. the rpc function added a layer of abstraction and some basic validation, but it still ran on the client-side, so anyone could see the rpc call and submit scores using another simple curl command:

```bash
curl 'https://supabase.co/rest/v1/rpc/submit_score' \
 -H 'apikey: <supabase-key>' \
 --data-raw '{"username":"hacker","score":999999}'
```

still a piece of cake.

## adding server-side validation

alas, i realized that i'd need a more robust solution to at least make hackers break a sweat, so i moved the score submission logic to the server. the server would validate the score by checking the timestamp: you could only submit a score where the time-to-score ratio made sense (e.g. 1 point per second). this was a step in the right direction, but again, determined hackers found a workaround by sending carefully crafted requests with all the expected headers and parameters:

```bash
# submit a score with manipulated data
curl 'https://www.basecase.sh/api/submit-score' \
  -H 'accept: */*' \
  -H 'content-type: application/json' \
  -H 'origin: https://www.basecase.sh' \
  -H 'referer: https://www.basecase.sh/' \
  --data-raw '{"username":"ejcx","score":1337,"gameStartTime":1721889984973}'
```

this was a pretty reasonable fix, but it was still too easy to hack.

## introducing jwt tokens

to make it harder, i implemented jwt tokens. here's how it worked:

1. when a game started, the client requested a token from the server.
2. the token was tied to the start time of the game.
3. when the game ended, the token was submitted along with the score.

this meant that hackers couldn't easily fake timestamps anymore because the token's start time was baked into its payload. even if they fetched a token, they'd have to wait in real-time to submit a high score, and tokens expired after 10 minutes.

and of course, people still found a way to hack it:

```bash
# fetch a game token
TOKEN=$(curl www.basecase.sh/api/start-game -XPOST | jq -r .token)

# wait 5 seconds, then submit a score
curl -d "{\"gameToken\":\"$TOKEN\", \"username\":\"hacker\", \"score\":5}" www.basecase.sh/api/submit-score
```

this added a lot more friction for hackers, but i still wasn't done.

## detecting unrealistic scores

finally, i added a manual check for suspiciously high scores. if someone submitted a score over 300, the server would reject it with a message that poked a little fun:

```javascript
// check for suspiciously high scores
if (score > 300) {
  return NextResponse.json({ 
    error: "nice try! scores over 300 aren't possible... yet ðŸ˜‰" 
  }, { status: 400 })
}
```

lessons learned
this journey taught me a lot about securing small projects:

1. client-side code is never secure. anything on the client can and will be inspected, so always validate on the server.
2. layered defenses work best. combining techniques (e.g., backend validation, tokens, and manual checks) makes it much harder to hack a system.
3. embrace the playful side. adding a fun response to suspicious scores made the game feel less rigid and more personal.

if you're a dev working on your own projects, i hope this breakdown helps you think about security in a practical way. and if you happen to submit a 300+ score, donâ€™t forget to send me a screenshot :)
